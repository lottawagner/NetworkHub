---
title: "NetworkHub: An R/Bioconductor package to streamline protein-protein interaction network analysis"
author: 
- name: Lotta Wagner
  affiliation: 
  - &id1 Institute of Medical Biostatistics, Epidemiology and Informatics (IMBEI), Mainz
  email: wagnerlo@uni-mainz.de
- name: Federico Marini
  affiliation: 
  - *id1
  email: marinif@uni-mainz.de
output: 
  rmarkdown::html_document:
    toc: true
    toc_float: true
    theme: cosmo
    code_folding: show
    code_download: true
    global_numbering: true
    number_sections: true
editor_options: 
  chunk_output_type: console
link-citations: true
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('NetworkHub')`"
vignette: >
  %\VignetteIndexEntry{networkhub_string}
  %\VignetteEncoding{UTF-8}  
  %\VignetteEngine{knitr::rmarkdown}
---

# About NetworkHub#TODO






# Setting up NetworkHub#TODO

```{r eval = FALSE}
if(!requireNamespace("NetworkHub", quietly = TRUE))
    install.packages("NetworkHub")
BiocManager::install("NetworkHub")
``` 

If you want to install the development version from GitHub, you can alternatively run this command:

```{r}
#BiocManager::install("imbeimainz/NetworkHub")
```


setup

After installation you can load and attach the NetworkHub package as follows:

```{r}
#library("NetworkHub")
```


explain cache


Initialization of the cache of "NetworkHub"

```{r init}
#initialize_NetworkHub(nh_cachedir = "NetworkHub")
```

# Using NetworHub

To demonstrate the benefits of NetworkHub, we will use the Macrophage dataset to simulate a scenario in which NetworkHub is useful. 


## Load the data

Before we can start, we have to take a few more steps. This includes loading all the required packages:

```{r stringdb requiered packages for DE, eval = FALSE}

if(!requireNamespace("GeneTonic", quietly = TRUE))
    install.packages("GeneTonic")
BiocManager::install("GeneTonic")
```

Now we can load the SE experiment data object ("gse") from the Macrophage(<https://www.bioconductor.org/packages/release/data/experiment/html/macrophage.html>) datatset: 

```{r load from macrophage}

# dds object
library("macrophage") #demo dataset
library("DESeq2") #package to perform differential expression analysis
library("org.Hs.eg.db") #Annotation package for human genes with info about gene identifier, chromosome location, Entrez-Gene, GO-terms, ...  
library("AnnotationDbi") #Annotation package 

data("gse", package = "macrophage") #gse dataset in macrophage = summarized experiment object 
dds_macrophage <- DESeq2::DESeqDataSet(gse, design = ~ line + condition) #creation of the DESeq data object out of gse by taking corresponding design into account ( effect in condition by looking at one cell line)

rownames(dds_macrophage) <- substr(rownames(dds_macrophage), 1, 15) # make sure to only take the first 15 digits of the identifier (e.g "ENSG00000066322" and not "ENSG00000066322.14")
dds_macrophage <- estimateSizeFactors(dds_macrophage) # normalizes data
```

Using GeneTonic we can retrieve a DE object from the macrophage dataset, which we can later integrate into a summerized experiment (SE) object together with the previously created dataframe <dds_macrophage> containing rows with the ENSEMBLE gene symbols and columns containing the colData for the different samples and conditions. 

To compare the condition: IFNg vs naive you can use "res_macrophage_IFNg_vs_naive" DE object from GeneTonic containg rows with the ENSEMBL gene symbols and columns with the DE results ( baseMean, log2FoldChange, pvalue, ...).

```{r loadde from GeneTonic}

# res object
data(res_de_macrophage, package = "GeneTonic") #get/take a differential expressed datafile
res_de <- res_macrophage_IFNg_vs_naive #use for example an DE datafile to look into the differential expressed genes in IFNg exposed vs naive macrophages
```
 
To perform a differential expression anlaysis "on your own" you can run the following lines: 


```{r DE}
data(gse, package = "macrophage")
dds_macrophage <- DESeqDataSet(gse, design = ~ line + condition)
#> using counts and average transcript lengths from tximeta
rownames(dds_macrophage) <- substr(rownames(dds_macrophage), 1, 15)
keep <- rowSums(counts(dds_macrophage) >= 10) >= 6
dds_macrophage <- dds_macrophage[keep, ]

dds_macrophage <- DESeq(dds_macrophage)
res_macrophage_IFNg_vs_naive <- results(dds_macrophage,
                                        contrast = c("condition", "IFNg", "naive"),
                                        lfcThreshold = 1, 
                                        alpha = 0.05)
```

With these two objects ( dds_macrophage & res_de) we can create a SE object that contains all the dds info AND the results of a DEA and can be further used in NetworkHub :) 

```{r SE}
#SE object

dds <- dds_macrophage
de_res <- res_de
de_name <- "ifngVSnaive"

combine_dds_deres <- function(dds, de_res, de_name) {
  matched_ids <- match(rownames(res_de), rownames(dds))
  rowData(dds)[[paste0(de_name, "_log2FoldChange")]] <- NA
  rowData(dds)[[paste0(de_name, "_pvalue")]] <- NA
  rowData(dds)[[paste0(de_name, "_padj")]] <- NA
  
  rowData(dds)[[paste0(de_name, "_log2FoldChange")]][matched_ids] <- res_de$log2FoldChange
  rowData(dds)[[paste0(de_name, "_pvalue")]][matched_ids] <- res_de$pvalue
  rowData(dds)[[paste0(de_name, "_padj")]][matched_ids] <- res_de$padj
  
  return(dds)

}

se_macrophage <- combine_dds_deres(dds_macrophage, res_de, "ifng_vs_naive")

de_res_scrambles <- de_res
de_res_scrambles$log2FoldChange <- rnorm(17806, sd = 2)


se_macrophage
```

#TODO1-11-2024

Going from the DE genes to the proteins...

```{r get networkdata string}

proteins_string <- get_networkdata_stringdb(species = "Homo sapiens",
                                     version = "12.0",
                                     cache = TRUE,
                                     add_annotation = TRUE)

unique_proteins_string <- unique(proteins_string$Ensembl_A, proteins_string$Ensembl_B)

first_proteins <- SE_dataframe_string$Ensembl[match(first_degenes, proteins_string)] |> 
  na.omit()

first_proteins
```

Getting a subnetwork for the DE proteins...

```{r makegraph}
library("igraph")
de_proteins_subgraph <- build_graph_stringdb(graph_data = sdb_human, 
                                             output_format = "igraph",
                                             min_score_threshold = 200,
                                             subset_nodes = first_proteins)

plot(de_proteins_subgraph)

# re-sort the nodes alphabetically? makes sense
rank_gs <- rank(V(de_proteins_subgraph)$name)
de_proteins_subgraph <- permute.vertices(de_proteins_subgraph, rank_gs)
visNetwork::visIgraph(de_proteins_subgraph) %>%
  visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                     degree = 1,
                                     hover = TRUE),
             nodesIdSelection = TRUE)

V(de_proteins_subgraph)
str(V(de_proteins_subgraph))
```

Starting to have fun with interactive networks...  
Makes sense to display the gene names

```{r plotround1}
de_proteins_subgraph

de_graph <- de_proteins_subgraph

# renaming the nodes, using the gene symbols
V(de_graph)$name <- 
  anno_df_string$ensembl_id[match(V(de_graph)$name, anno_df_string$protein_id)]

de_graph <- igraph::induced.subgraph(de_graph, which(!is.na(V(de_graph)$name)))
de_graph_ens <- de_graph

# re-sort the nodes alphabetically? makes sense
rank_gs <- rank(V(de_graph)$name)
de_graph <- permute.vertices(de_graph, rank_gs)
visNetwork::visIgraph(de_graph) %>%
  visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                     degree = 1,
                                     hover = TRUE),
             nodesIdSelection = TRUE)
```

Now: putting on top the info from the expression values and their changes

```{r extraplots}
# different colors for the nodes in function of their logFC
# set.seed(42)
# fcs_genes <- rnorm(mean = 0, sd = 3, n = length(V(de_graph)))

str(V(de_graph))

intersect(V(de_graph)$name, first_degenes)

V(de_graph)$log2FC

V(de_graph)$log2FC <- res_de$log2FoldChange[match(V(de_graph)$name, rownames(res_de))]

mypal <- rev(scales::alpha(
  colorRampPalette(RColorBrewer::brewer.pal(name = "RdBu", 11))(50), 0.4
))

max_de <- max(abs(range(V(de_graph)$log2FC)))

V(de_graph)$color <- GeneTonic::map2color(V(de_graph)$log2FC, mypal, limits = c(-max_de, max_de))

gene_ids_backup <- V(de_graph)$name
gene_names <- anno_df_string$gene_symbol[match(gene_ids_backup, anno_df_string$ensembl_id)]
new_names <- gene_names
new_names[is.na(new_names)] <- gene_ids_backup[is.na(new_names)]
V(de_graph)$name <- new_names

rank_gs <- rank(V(de_graph)$name)
de_graph <- permute.vertices(de_graph, rank_gs)

# title for tooltips
V(de_graph)$title <- NA

V(de_graph)$title <- paste0(
  "<h4>", V(de_graph)$name, "</h4><br>",
  "logFC = ", format(round(V(de_graph)$log2FC, 2), nsmall = 2)
)

visNetwork::visIgraph(de_graph) |> 
  visNetwork::visEdges(color = list(color = "#88888888")) |> 
  visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                                 degree = 1,
                                                 hover = TRUE),
                         nodesIdSelection = TRUE)
```


# Trying to go 1 on 1 vs the STRINGDB vignette!

```{r sdbvignette}
library("STRINGdb")
library("igraph")

string_db <- STRINGdb$new(version="11.5", 
                          species=9606,
                          score_threshold=200, 
                          network_type="full", 
                          input_directory="../dev/sdb_human/")

data(diff_exp_example1)
head(diff_exp_example1)

example1_mapped <- string_db$map( diff_exp_example1, "gene", removeUnmappedRows = TRUE )

hits <- example1_mapped$STRING_id[1:600]
string_db$plot_network(hits)

# get clusters
clustersList <- string_db$get_clusters(example1_mapped$STRING_id[1:600])
# plot first 4 clusters
par(mfrow=c(2,2))
for(i in seq(1:4)) {
  string_db$plot_network(clustersList[[i]])
}
```


```{r sdbnh}
# similarly, with our interactive thingoooooos...
ppi_human_v11.5 <- get_networkdata_STRINGDB(species = "Homo sapiens",
                                            version = "11.5")


network_desubset_600 <- build_graph_STRINGDB(graph_data = ppi_human_v11.5, 
                                             output_format = "igraph",
                                             min_score_threshold = 200,
                                             subset_nodes = example1_mapped$STRING_id[1:600])



# clustering the main graph like...

clu_graph_walktrap <- walktrap.community(network_desubset_600,merges=TRUE, modularity=TRUE)
clu_graph_fastgreedy <- fastgreedy.community(network_desubset_600,merges=TRUE, modularity=TRUE)
clu_graph_markov <- GeneTonic::cluster_markov(network_desubset_600)
clu_graph_louvain <- igraph::cluster_louvain(network_desubset_600)

table(membership(clu_graph_walktrap))
table(membership(clu_graph_fastgreedy))
table(membership(clu_graph_markov))
table(membership(clu_graph_louvain))

memb_to_use <- membership(clu_graph_walktrap)
memb_to_use <- membership(clu_graph_fastgreedy)
memb_to_use <- membership(clu_graph_louvain)

V(network_desubset_600)$membership <- memb_to_use
V(network_desubset_600)$color <- memb_to_use

visNetwork::visIgraph(network_desubset_600) %>%
   visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                                    degree = 1,
                                                    hover = TRUE),
                            nodesIdSelection = TRUE,
                          selectedBy = "membership")
```


```{r allclusts}
clustersList_redone <- list()

for(i in 1:max(memb_to_use)){
  clustersList_redone[[i]] <- names(memb_to_use[memb_to_use == i])
}

cluster_networks <- lapply(clustersList_redone[1:4], function(arg) {
  build_graph_STRINGDB(graph_data = ppi_human_v11.5, 
                       output_format = "igraph",
                       min_score_threshold = 200,
                       subset_nodes = arg)
})

visNetwork::visIgraph(cluster_networks[[1]]) %>%
  visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                                 degree = 1,
                                                 hover = TRUE),
                         nodesIdSelection = TRUE)

visNetwork::visIgraph(cluster_networks[[2]]) %>%
  visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                                 degree = 1,
                                                 hover = TRUE),
                         nodesIdSelection = TRUE)

visNetwork::visIgraph(cluster_networks[[3]]) %>%
  visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                                 degree = 1,
                                                 hover = TRUE),
                         nodesIdSelection = TRUE)

visNetwork::visIgraph(cluster_networks[[4]]) %>%
  visNetwork::visOptions(highlightNearest = list(enabled = TRUE,
                                                 degree = 1,
                                                 hover = TRUE),
                         nodesIdSelection = TRUE)

```


# Ok, bringing this into functions to make it streamlined

```{r mapse}
de_graph # would have to be with gene identifiers as in the SE
se_macrophage
annotation_df <- anno_df_string

rowdata_to_map <- "macrores_log2FoldChange"
assay_name <- "counts"


gg <- NetworkHub:::map_se_onto_graph(de_graph_ens, 
                                     se_macrophage, 
                                     anno_df_string, 
                                     assay_name = "counts")

gg

NetworkHub:::iplot_graph(gg, color_nodes_by = "macrores_log2FoldChange")

gg_genenames <- gg
genesymbols_matched <- anno_df_string$gene_symbol[match(V(gg)$name, anno_df_string$ensembl_id)]

scater::uniquifyFeatureNames(V(gg)$name, genesymbols_matched)
V(gg_genenames)$name <- scater::uniquifyFeatureNames(V(gg)$name, genesymbols_matched)

NetworkHub:::iplot_graph(gg_genenames, color_nodes_by = "macrores_log2FoldChange")
```



# Session Info {-}

```{r sessioninfo}
sessionInfo()
```

